Creating and Mounting File Systems

Module Topics

    Mounting File Systems Manually

    Unmounting File Systems

    Accessing Removable Storage Devices

    Disk Partitioning

    Managing MBR Partitions With fdisk

    Managing GPT Partitions With gdisk

    Creating File Systems

    Mounting File Systems

    Swap Space Concepts

    Create a Swap Space

    Activate a Swap Space


Mounting File Systems Manually

    Need to manually mount file system on SATA/PATA or SCSI device

    Use mount

        First argument specifies file system to mount

        Second argument specifies directory where file system resides after mounting

            Called mount point

    Two ways mount expects file system argument:

        Device file of partition holding file system

            Resides in /dev

        UUID

            Universal unique identifier of file system

            Does not change unless file system is re-created, even if device order changes or new devices are added to system

Use mount

    First argument specifies file system to mount

    Second argument specifies directory where file system resides after mounting

        Called mount point

Two ways mount expects file system argument:

    Device file of partition holding file system

        Resides in /dev

    UUID

        Universal unique identifier of file system

        Does not change unless file system is re-created, even if device order changes or new devices are added to system

Partitions and UUID

    blkid gives overview of:

        Partitions with file system on them

        File system UUID

        File system used to format partition

        [root@server1~]# blkid
        /dev/vda1:UUID="46f543fd-78c9-4526-a857-244811be2d88" TYPE="xfs"

    Can mount file system on existing directory

        Default /mnt directory provides entry point for mount points

        Recommended: Create subdirectory under /mnt to use as mount point

    To mount by partition device file:

    [root@server1~]# mount /dev/vdb1 /mnt/mydata

    To mount by file system UUID:

    [root@server1~]# mount UUID="46f543fd-78c9-4526-a857-244811be2d88" /mnt/mydata

    If mount point is not empty, file in mount point not accessible while file system is mounted

    All files written to mount point directory appear on file system mounted there



Unmounting File Systems

    To unmount file system, use umount

        Expects mount point as argument

        Example:

            Change to /mnt/mydata directory

            Try to unmount device on /mnt/mydata mount point

            It fails

            [root@server1~]# cd /mnt/mydata
            [root@server1mydata]# umount /mnt/mydata

Processes That Prevent Unmounting

    Cannot unmount if process accesses mount point

    Need to stop access to unmount

    To list all open files and process accessing them in directory, use lsof

        Use to identify processes preventing file system from unmounting

        [root@server1mydata]# lsof /mnt/mydata

After identifying, can take action

    Wait for process to complete

    Send SIGTERM or SIGKILL signal

    Change directory to directory outside mount point

    [root@server1mydata]# cd
    [root@server1~]# umount /mnt/mydata

Common reason mount point is busy - Current directory of shell prompt is below active mount point

    bash process is accessing mount point

    To unmount device, change to directory outside mount point


Accessing Removable Storage Devices

    Graphical desktop environment automatically mounts removable media, i.e., USB flash devices and drives

    Mount point for removable medium: /run/media/<user>/<label>

        <user> is user logged in to graphical environment

        <label> is name given to file system when created

    

    Must unmount USB media before removing it

    Removing without unmounting can cause data loss

    For more info on mounting and unmounting file systems, see these man pages: mount(8), umount(8), and lsof(8).


Disk Partitioning

    Disk partitioning: Lets you divide hard drive into multiple logical storage units (partitions)

    Can use different partitions to perform different functions, such as:

        Limit available space to applications or users

        Allow multibooting of different operating systems from same disk

        Separate operating system and program files from user files

        Create separate area for OS virtual memory swapping

        Limit disk space usage to improve diagnostic/imaging performance


MBR Partitioning Scheme

    Master Boot Record (MBR): Dictates how to partition disks on BIOS firmware systems

    Supports maximum four primary partitions

    On Linux, can use extended and logical partitions to create maximum 15 partitions

    Partition size data stored as 32-bit values

    Disks partitioned with MBR have maximum 2 TiB disk/partition size limit

    2 TiB limit presents real-world problem encountered frequently in production environments

    MBR scheme being superseded by GUID Partition Table (GPT)


GPT Partitioning Scheme

    GPT: Standard for laying out partition tables on hard disks for Unified Extensible Firmware Interface (UEFI) firmware systems

    Part of UEFI standard

    Addresses many limitations of MBR-based scheme

    Supports up to 128 partitions

    Allocates 64 bits for logical block addresses

    Can accommodate partitions and disks of up to 8 ZiB (8 billion TiB)

        8 ZiB limit based on 512-byte block size

        With 4,096-byte blocks, limitation increases to 64 ZiB

    Uses 128-bit GUIDs to identify disks and partitions

    Offers redundancy of partition table information

        Primary GPT resides at head of disk

        Backup copy/secondary GPT housed at end of disk

    Employs CRC checksum to detect errors and corruption


Managing MBR Partitions With fdisk

    Partition editors let administrators make changes to disk partitions

        Creating partitions, deleting partitions, changing partition types

    Can use fdisk partition editor to perform operations for MBR scheme disks


Managing MBR Partitions With fdisk
Creating MBR Disk Partitions

    Specify disk device on which to create partition:

    [root@server1~]# fdisk /dev/vdb

Identify partition number of partition to delete:

Command (m for help):p

Request partition deletion:

Command (m for help):d

Save partition table changes:

Command (m for help):w

Initiate kernel re-read of new partition table:

[root@server1~]# partprobe /dev/vdb


Managing GPT Partitions With gdisk

    Can use gdisk partition editor to manage partitions for GPT partitioning scheme disks

    Use gdisk with GPT partitioning scheme

        GPT support for fdisk experimental


Creating GPT Disk Partitions

    Specify disk device on which to create partition:

    [root@server1~]# gdisk /dev/vdb

Creating File Systems

    After creating block device, must apply file system format to it

        File system applies structure to block device

        Lets you store and retrieve data device

    Red Hat Enterprise Linux supports many file system types

        Two common types: xfs and ext4

        anaconda (Red Hat Enterprise Linux installer) uses xfs by default

    To apply file system to block device, use mkfs

        To specify file system type, use -t

        If no type specified, ext2 used by default

        [root@server1~]# mkfs -t xfs /dev/vdb1

Mounting File Systems

    After applying file system format, need to attach file system into directory structure

    Lets user space utilities access or write files on device


Manually Mounting File Systems

    To manually attach device to directory location (mount point), use mount

    Specify:

        Device

        Mount point

        Any option desired to customize device behavior

        [root@server1~]# mount /dev/vdb1 /mnt

    Can also use mount to view:

        Currently mounted file systems

        Mount points

        Options

        [root@server1~]# mount | grep vdb1

Manually mounting file system lets you verify that formatted device is accessible/working as desired

After system reboot, file system exists and has intact data but is not mounted into directory tree again

To permanently mount file system, add listing for file system to /etc/fstab


Persistently Mounting File Systems

    To configure device to be mounted to mount point at system boot, add device listing in /etc/fstab

    /etc/fstab is white space-delimited file with six fields per line

    [root@server1~]# cat /etc/fstab

First field specifies device to be used (example uses UUID)

    Could also use device file; for example, /dev/vdb1

        UUID is stored in file system superblock and created at same time as file system

        Recommended: Use UUID; remains intact if block device identifiers change


blkid

    To scan block devices connected to machine, use blkid

        Also reports on data like assigned UUID and file system format

        [root@server1~]# blkid /dev/vdb1
        /dev/vdb1:UUID="226a7c4f-e309-4cb3-9e76-6ef972dd8600" TYPE="xfs"

    Second field is mount point at which to attach device into directory hierarchy

        Mount point should already exist

        If not, use mkdir to create

    Third field contains file system type applied to block device

    Fourth field lists options to apply to mounted device to customize behavior

        Required field

        defaults contains set of commonly used options
    For other options, see mount man page

Last two fields are dump flag and fsck order

    Use dump flag with dump to make a backup of device contents

    fsck order field determines if fsck should run at boot time if file system did not unmount cleanly

    fsck order value indicates order in which file systems should have fsck run on them

UUID=226a7c4f-e309-4cb3-9e76-6ef972dd8600  /mnt  xfs  defaults  1 2

    Incorrect entry in /etc/fstab may render the machine unbootable

    To verify entry is valid:

        Unmount new file system

        Mount file system back into place using mount -a, which reads /etc/fstab

            If mount -a returns error, correct this before rebooting machine

    For more info on adding partitions, file systems, and persistent mounts, see these man pages: fdisk(8), gdisk(8), mkfs(8), mount(8), fstab(5).



Swap Space Concepts

    Swap space: Disk area you can use with Linux kernel memory management subsystem

        Use to supplement system RAM by holding inactive pages of memory

        System RAM + swap spaces = Virtual memory

    When system memory usage exceeds limit, kernel:

        Combs RAM looking for idle memory pages assigned to processes

        Writes idle page to swap area

        Reassigns RAM page to another process

    If program requires access to page written to disk, kernel:

        Locates another idle memory page

        Writes it to disk

        Recalls needed page from swap area

Swap slow compared to RAM

Keep use of swap to a minimum


Create a Swap Space

    Create partition

    Set partition type as 82 Linux Swap

    Format swap signature on device


Create a Partition

    Use tool such as fdisk to create partition

        Example: Create 256 MiB partition

        [root@server1~]# fdisk /dev/vdb


Assign the Partition Type

    Recommended: Change created partition’s type (system ID) to 82 Linux Swap

    Setting partition type helps administrators determine partition’s purpose

    Command (m for help):t

Format the Device

    To apply swap signature to device, use mkswap

    Writes single block of data at beginning of device

        Leaves rest of device unformatted

        [root@server1~]# mkswap /dev/vdb1

Activate a Swap Space

    To activate formatted swap space, use swapon

    To activate all swap spaces listed in /etc/fstab, use swapon -a

    Can call swapon on device

    [root@server1~]# free

Persistently Activate Swap Space

    Swap space likely needs to automatically activate with every machine boot

        Must configure this in /etc/fstab

    Can use swapoff to deactivate swap space

    Works only if swapped data can be written to other active swap spaces or back into memory


Swap Space Priorities

    Default: Swap spaces used in series

        First activated swap space used until full, then kernel starts using second swap space

    To display swap space priorities, use swapon -s

    To set priorities, use pri= mount option

    If swap spaces have same priority, kernel writes to them round-robin

For more info on managing swap space, see these man pages: mkswap(8), swapon(8), swapoff(8), mount(8), fdisk(8).


